#+INCLUDE: "~/git_repos/PVA-parrot/PVA-Parrot/org/org_settings_weave.org"

#+PROPERTY: mkdirp yes
#+TODO: CHORE(c!) BUG(b!) IDEA(i!) | FIXED(f!)

* Introduction
  PVA-Parrot is an application for doing polytopic vector analysis. This is the
  main application.

* Project Information

  The application version:
  #+BEGIN_SRC clojure :noweb-ref version
  "0.1.0"
  #+END_SRC

  The application description:
  #+BEGIN_SRC clojure :noweb-ref description
  "A GUI application for polytopic vector analysis (PVA)."
  #+END_SRC

* Developing and building

 Instructions about developing and building the application.

** IDEA use CLJSJS
   :LOGBOOK:
   - State "IDEA"       from ""           [2015-03-07 Sat 21:09]
   - State "IDEA"       from ""           [2015-03-07 Sat 17:34]
   :END:


** Prerequisites
   A JVM installation is required.

   Boot needs to be installed:
   #+BEGIN_SRC bash
   $ mv boot.sh boot && chmod a+x boot && sudo mv boot /usr/local/bin
   #+END_SRC

** Boot project setup

    #+BEGIN_SRC clojure :noweb no-export :tangle ../build.boot
    (set-env!
      <<boot source paths>>
      <<boot resource paths>>
      :dependencies '[
        <<boot dependencies>>
      ])

    <<boot tasks>>

    (task-options!
      <<boot tasks options>>)
    #+END_SRC

*** Classpath declarations

    Source paths are where source code files reside, both Clojure and
    Clojurescript paths are given and namespaces will be added to the classpath
    by boot.

    #+BEGIN_SRC clojure :noweb-ref "boot source paths"
      :source-paths #{"src/cljs" "src/clj"}
    #+END_SRC

    The resource paths will be on the classpath, too. Files in the resource
    paths will be treated as final articats in the build.

    #+BEGIN_SRC clojure :noweb-ref "boot resource paths"
      :resource-paths #{"resources"}
    #+END_SRC

*** Dependencies declaration
    :PROPERTIES:
    :noweb-ref: boot dependencies
    :END:

   - Clojurescript :: essential for the GUI client logic.
   - boot-cljs :: compilation of cljs files from boot tasks
   - boot-cljs-repl :: Clojurescript repl support
   - boot-reload :: trigger reload in browser when files changes
   - boot-http :: a simple HTTP serve task
   - boot-notify :: visual notifications of boot build status
   - boot-garden :: compile garden data to CSS
   - boot-test :: run clojure.test tests
   #+BEGIN_SRC clojure
   [org.clojure/clojurescript "0.0-2814"]
   [adzerk/boot-cljs      "0.0-2814-1"      :scope "test"]
   [adzerk/boot-cljs-repl "0.1.9"           :scope "test"]
   [adzerk/boot-reload    "0.2.4"           :scope "test"]
   [pandeiro/boot-http    "0.6.3-SNAPSHOT"  :scope "test"]
   [jeluard/boot-notify   "0.1.1"           :scope "test"]
   [boot-garden           "1.2.5-2"         :scope "test"]
   [adzerk/boot-test      "1.0.4"           :scope "test"]
   #+END_SRC

   - reagent :: clojurescript library for Facebook React, used for UI
        programming, linking app state with UI
   - sente :: socket and AJAX communication library, backend and frontend
   - encore :: a depenendcy of =sente= and =timbre=, explicitly added to prevent
        [[https://github.com/ptaoussanis/encore/blob/master/DEP-CONFLICT.md][dependency version conflicts]]
   #+BEGIN_SRC clojure
   [reagent               "0.5.0-alpha3"]
   [com.taoensso/encore   "1.21.0"]
   [com.taoensso/sente    "1.3.0"]
   [garden                "1.2.5"]
   #+END_SRC


**** Backend dependencies
     #+BEGIN_SRC clojure
     [ring/ring-core      "1.3.2"]
     [http-kit            "2.1.19"]
     [compojure           "1.3.1"]
     [com.taoensso/timbre "3.4.0"]
     [org.clojure/data.csv "0.1.2"]
     #+END_SRC

     Backend calculations are using Incanter. Using the latest stabel version 1.5.6
     for now.
     #+BEGIN_SRC clojure
     [incanter "1.5.6"]
     #+END_SRC


*** Tasks definitions
    These are the tasks for the GUI application. Libs may define their own,
    additional tasks, e.g. [[id:libs-backend]]

    Tasks from the boot community are available at
    https://github.com/boot-clj/boot/wiki/Community-Tasks

    #+BEGIN_SRC clojure :noweb-ref "boot tasks"
    (require
      '[adzerk.boot-cljs      :refer [cljs]]
      '[adzerk.boot-cljs-repl :refer [cljs-repl start-repl]]
      '[adzerk.boot-reload    :refer [reload]]
      '[adzerk.boot-test      :refer :all]
      '[pandeiro.boot-http    :refer [serve]]
      '[boot-garden.core      :refer [garden]]
      '[jeluard.boot-notify   :refer [notify]])

    (deftask build []
      (comp
        (notify)
        (cljs)
        (garden :styles-var 'pva-parrot.styles/base
          :vendors ["webkit"]
          :auto-prefix #{:align-items}
          :output-to "css/garden.css")))

    (deftask dev-run []
      (comp (serve)
        (watch)
        (reload)
        (build)))

    (deftask production []
      (task-options! cljs {:optimizations :advanced
                           :compiler-options {:closure-defines {:goog.DEBUG false}}}
        garden {:pretty-print false})
      identity)

    (deftask development []
      (task-options! cljs {:optimizations :none
                           :unified-mode true
                           :source-map true}
        reload {:on-jsload 'pva-parrot.app/init})
      identity)

    (deftask prod
      "Simple alias to run application in production mode
           No REPL or automatic reloading code inserted."
      []
      (comp (production)
        (serve)
        (watch)
        (build)))

    (deftask dev
      "Simple alias to run application in development mode"
      []
      (comp (development)
        (dev-run)))
    #+END_SRC

    Tasks for running tests. The =/test= directory needs to be added to the
    =:source-paths= to make the tests available on the classpath.

    #+BEGIN_SRC clojure :noweb-ref "boot tasks"
    (deftask run-tests
      "Run all PVA-Parrot tests"
      []
      (set-env! :source-paths #(conj % "test"))
      (test))

    #+END_SRC

**** Boot tasks for backend service

     Start the backend server and the GUI client via =boot serve-backend dev=

     boot task to start the backend server:
     #+BEGIN_SRC clojure :noweb-ref "boot tasks"
     (deftask serve-backend []
       (comp
         (serve :handler 'pva-parrot.backend.service/api
           :reload true
           :httpkit true
           :port 3333)))
     #+END_SRC

 #
*** Tasks options
    :PROPERTIES:
    :noweb-ref: boot tasks options
    :END:
    The macro =task-options!= is used to specify options for tasks. It gets
    passed pairs of tasks and this task's options as a map.

    Options for creating a maven pom.xml project declaration file:
    #+BEGIN_SRC clojure
    pom {:project 'pva-parrot
         :version <<version>>
         :description <<description>>}
    #+END_SRC

** Continuous Integration
*** travis CI
    #+BEGIN_SRC ruby :tangle ../.travis.yml
    language: clojure
    jdk:
    - oraclejdk8
    install:
    # Install Emacs24
    - sudo apt-add-repository -y ppa:cassou/emacs
    - sudo apt-get update
    - sudo apt-get install -y emacs24 emacs24-el emacs24-common-non-dfsg

    # Install Org-Mode
    - mkdir ~/elisp
    - git clone git://orgmode.org/org-mode.git ~/elisp/org-mode
    - pushd ~/elisp/org-mode && make autoloads
    - popd

    # Tangle clojure files
    - ./org/tangle.sh ./org/pva-parrot.org

    # Install Boot
    - wget https://github.com/boot-clj/boot/releases/download/2.0.0-rc12/boot.sh
    - mv boot.sh boot && chmod a+x boot

    script: ./boot run-tests

    #+END_SRC

*** drone.io
    drone.io is used as a CI service. The project can be found at
    https://drone.io/github.com/PVA-Parrot/PVA-Parrot

    A push to github will trigger running tests on the latest revision.

    The build commands run on the CI are:
    #+BEGIN_SRC bash
    # Install Emacs24
    sudo apt-add-repository ppa:cassou/emacs
    sudo apt-get update
    sudo apt-get install emacs24 emacs24-el emacs24-common-non-dfsg

    # Install Org-Mode
    mkdir ~/elisp
    git clone git://orgmode.org/org-mode.git ~/elisp/org-mode
    cd ~/elisp/org-mode && make autoloads

    # go back to project directory
    cd /home/ubuntu/src/github.com/PVA-Parrot/PVA-Parrot

    # Tangle clojure files
    ./org/tangle.sh ./org/pva-parrot.org

    # Install Boot
    wget https://github.com/boot-clj/boot/releases/download/2.0.0-rc12/boot.sh
    mv boot.sh boot && chmod a+x boot && sudo mv boot /usr/local/bin

    # back to project directory and start tests
    cd /home/ubuntu/src/github.com/PVA-Parrot/PVA-Parrot
    boot run-tests
    #+END_SRC

** Troubleshooting
*** JVM Config and Java 8

    boot-clj suggests some options for boot to prevent issues with the JVM: [[https://github.com/boot-clj/boot/wiki/JVM-Options][boot JVM Options]]

    #+BEGIN_SRC bash
    $ echo $BOOT_JVM_OPTIONS
    -Xmx2g -client -XX:+TieredCompilation -XX:TieredStopAtLevel=1 -XX:MaxPermSize=128m -XX:+UseConcMarkSweepGC -XX:+CMSClassUnloadingEnabled -Xverify:none
    #+END_SRC

    I still had memory issues when running boot tasks. Upgrading to Java 8 seems to have fixed theses issues. So I
    recomment using Java 8.

* GUI Application

** Application logic

   Execute =boot dev= to access the application on http://localhost:3000.

   The structure of the main application is like this:
   #+BEGIN_SRC clojure :noweb no-export :tangle ../src/cljs/pva_parrot/app.cljs
   <<app namespace>>
   <<app state>>
   <<app user interface components>>
   <<app pages>>
   <<app page component>>
   <<app event handling>>
   <<app initialization and entry point>>
   #+END_SRC

*** Namespace
    The main namespace and entry point of the app.
    #+BEGIN_SRC clojure :noweb-ref "app namespace"

    (ns pva-parrot.app
      (:require [taoensso.encore :as enc    :refer (tracef debugf infof warnf errorf)]
                [pva-parrot.plot :as plot]
                [pva-parrot.websockets :as websockets]
                [reagent.core :as reagent :refer [atom]]))

    #+END_SRC

*** State
    :PROPERTIES:
    :noweb-ref: app state
    :END:

    Application state is kept in a single Reagent atom. Updating this atom
    triggers propagates changes to the Reagent UI components using data from
    this atom.

    #+BEGIN_SRC clojure

    (def app-state (atom {:page :welcome
                          :project {:name "My Project"}
                          :import-file nil
                          :parsed-data nil
                          :eigen-values nil
                          :eigen-vectors nil
                          }))

    #+END_SRC

    App state consists of the following data:

    - :page :: the page currently active
    - :import-file :: file to be imported/uploaded

    -----
    *Updating app state*

    The current page can be changed with the =swap-page= function:

    #+BEGIN_SRC clojure

    (defn swap-page [target]
      (swap! app-state assoc :page target))

    #+END_SRC

    To import text files, they get stored in in the =app-state= atom. The HTML5
    =FileReader= gets used to retrieve the file contents.

    #+BEGIN_SRC clojure
    (defn store-text-file!
      "Reads a file as text and swaps the result into the app-state for the given key."
      [file key]
      (let [reader (js/FileReader.)]
        (set! (.-onload reader)
          (fn [event]
            (let [file-content (aget event "target" "result")]
              (swap! app-state assoc key file-content))))
        (.readAsText reader file)))

    (defn import-file!
      [event]
      (let [file (aget event "target" "files" 0)]
        (store-text-file! file :import-file)))
    #+END_SRC

*** UI components
    :PROPERTIES:
    :noweb-ref: app user interface components
    :END:
**** Page component
     The page component holds references to the available pages. The active page
     is stored in the =app-state= atom and =page-component= reflects this to show
     the active page.
     #+BEGIN_SRC clojure :noweb-ref "app page component"

     (defn page-component []
       (let [pages {:welcome [welcome-page]
                    :pva-workbook [pva-workbook
                                   (reagent/cursor app-state [:project])]}]
         ((:page @app-state) pages)))

     #+END_SRC

**** Buttons
     The generic =styled-button= function is a Reagent component to render a
     button styled with twitter bootstrap css.

     Based on this base button, further button components are declared to handle
     specific use cases.

     #+BEGIN_SRC clojure

     (defn styled-button [& opts]
       (let [{:keys [style size click-handler contents]} opts
             classes (clojure.string/join " " [(when style (str "btn-" style))
                                               (when size  (str "btn-" size))])]
         [:button.btn {:class classes :on-click click-handler} contents]))

     (defn pages-button [target text & opts]
       [styled-button
         :contents text
         :style "primary"
         :size "lg"
         :click-handler #(swap-page target)])

     (defn back-button [target]
       [styled-button
         :size "sm"
         :contents "back"
         :click-handler #(swap-page target)])

     #+END_SRC

     Components to import files into the application. At the moment this is based
     on uploading a file to the backend via HTML form submissions. When using a
     desktop app shell, this might need to be changed.

**** Inputs
     #+BEGIN_SRC clojure
     (defn file-input []
       [:input.btn {:name "import-file" :type "file" :accept "text/csv"
                    :on-change import-file!}])

     (defn submit-file [this]
       (let [file-body (:import-file @app-state)
             event-data {:file-body file-body}]
         (.preventDefault this)
         (websockets/chsk-send! [:data-import/csv-sent event-data])))

     (defn submit-file-component [text]
       [:form.form-inline.well

        [:div.form-group
         [:label {:for "import-file"} text]
         [file-input]]

        [styled-button :style "primary"
         :contents "Import it"
         :click-handler submit-file]])
     #+END_SRC

**** Tables
     Tables for showing data. Using =DataTables= jQuery plugin.

     #+BEGIN_SRC clojure

     (defn table-header [headings]
       [:tr (map (fn [cell] [:th.dt-center cell]) headings)])

     (defn table-row [row]
       [:tr (map (fn [cell] [:td.dt-right cell]) row)])

     (defn table [{:keys [body headings]}]
       (if body
         [:table.table.display.compact
          (when headings
            [:thead
             [table-header headings]])
          [:tbody
           (map table-row body)
           ]]
         [:div]))

     (defn refresh-table [comp]
       (.DataTable (js/$ (reagent/dom-node comp))))

     (defn table-component [data]
       (reagent/create-class {:reagent-render table
                              :component-did-mount refresh-table
                              :component-did-update refresh-table}))

     #+END_SRC

**** Accordion
     An accordion to split the app UI into procedural sections. Based on the
     bootstrap accordion.

     #+BEGIN_SRC clojure
     (defn accordion-section [{:keys [key default title]} & contents]
       (let [id (str "collapse-" key)
             heading-id (str "heading-" key)]
         [:div.panel.panel-default
          [:div.panel-heading {:role "tab" :id heading-id}
           [:h1.panel-title
            [:a {:data-toggle "collapse"
                 :href (str "#" id) :aria-extended true
                 :aria-contols id}
             title]]]
          [:div.panel-collapse.collapse.in {:role "tabpanel" :id id
                                            :aria-labelledby heading-id}
           [:div.panel-body
            contents]
           ]]))

     (defn accordion-component [sections]
       [:div.panel-group {:role "tablist"}
        (for [section sections]
          (let [{:keys [key title content]} section]
            [accordion-section {:key key :title title} content]))])

     #+END_SRC

*** Pages

    =pva-workbook=  is the main page for the PVA analysis. It shows the user
    interface for a single project. The idea is to guide the user from top to
    bottom, doing a PVA analysis along the way.

    #+BEGIN_SRC clojure :noweb-ref "app pages"
    (defn workbook-section-data []
      [:div
       [submit-file-component "Import CSV Dataset"]
       [:h2 "Dataset:"]
       [table-component (@app-state :parsed-data)]])

    (defn workbook-section-components []
      [:div
       [:form.form.well
        [:p "Expected number of components"]
        [:div.form-group
         [:label {:for "components-min"} "min."]
         [:input {:name "components-min" :type "number" :min 2 :value 2}]]
        [:div.form-group
         [:label {:for "components-max"} "max."]
         [:input {:name "components-max" :type "number" :min 3 :value 5}]]]
       [:h3 "Eigenvalues"]
       [table-component (@app-state :eigen-values)]
       [:h3 "Eigenvectors"]
       [table-component (@app-state :eigen-vectors)]
       ])

    (defn workbook-section-proportions []
      [:div])

    (defn pva-workbook [project]
      [:div
       [:div.col-lg-12
        [back-button :welcome]]
       [:div.row
        [:div.col-lg-12
         [:h1 (str "Project: " (:name @project))]
         [accordion-component
          [{:key "analytical-data"
            :title "1. Analytical Data"
            :content [workbook-section-data]}
           {:key "sign-components"
            :title "2. Significant Components"
            :content [workbook-section-components]}
           {:key "comp-and-props"
            :title "3. Compositions and Proportions"
            :content [workbook-section-proportions]}
           ]]]]])
    #+END_SRC

    =welcome-page=  is the start screen of the application. Does not do much at
    all at the moment.

    #+BEGIN_SRC clojure :noweb-ref "app pages"
    (defn welcome-page []
      [:div#welcome-page
       [:div.jumbotron
        [:img.img-responsive {:src "img/parrot.png"}]
        [:h1 "PVA Parrot"]
        [:h2 "An application for polytopic vector analysis"]
        [:hr]
        [pages-button :pva-workbook "Go to Workbook"]]])
    #+END_SRC

*** Event handling
    :PROPERTIES:
    :noweb-ref: app event handling
    :END:

    The scheme for event message naming is <topic>/<action>. For
    example =:data-import/file-returned= identifies the event of finishing the
    import of a data file. On the event sender side this reads as "file GETS
    returned", on the receiver side it reads as "file WAS returned"

    #+BEGIN_SRC clojure

    (defmethod websockets/handle-event :data-import/file-returned
      [[_ data]]
      (debugf "Imported raw data and PCA data received.")
      (swap! app-state assoc :parsed-data (:parsed-data data))
      (swap! app-state assoc :eigen-values (:eigen-values data))
      (swap! app-state assoc :eigen-vectors (:eigen-vectors data)))

    #+END_SRC

*** Init and entry point
    #+BEGIN_SRC clojure :noweb-ref "app initialization and entry point"

    (defn init []
      (reagent.core/render-component [page-component]
        (js/document.getElementById "container")))

    #+END_SRC

** HTML entry point
   #+BEGIN_SRC html :tangle ../resources/index.html
   <!doctype html>
   <html>
     <head>
       <meta charset="utf-8">
       <title>PVA Parrot</title>
       <link href="css/bootstrap.min.css" rel="stylesheet" type="text/css" media="screen">
       <link href="//cdn.datatables.net/1.10.5/css/jquery.dataTables.min.css" rel="stylesheet" type="text/css" media="screen">
       <link href="css/garden.css" rel="stylesheet" type="text/css" media="screen">
     </head>
     <body>
       <div id="container" class="container-fluid">
         <!-- loading screen -->
         <div class="jumbotron">
           <p>PVA Parrot loading...</p>
           <p>Initializing application, please wait...</p>
         </div>
       </div>
       <script type="text/javascript" src="js/app.js"></script>
       <script type="text/javascript" src="//code.jquery.com/jquery-1.11.2.min.js"></script>
       <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/flot/0.8.3/jquery.flot.min.js"></script>
       <script type="text/javascript" src="//cdn.datatables.net/1.10.5/js/jquery.dataTables.min.js"></script>
       <script type="text/javascript" src="//cdn.datatables.net/plug-ins/f2c75b7247b/integration/bootstrap/3/dataTables.bootstrap.js"></script>
       <script type="text/javascript" src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.2/js/bootstrap.min.js"></script>
     </body>
   </html>
   #+END_SRC

** JS entry point

   #+BEGIN_SRC clojure :tangle ../resources/js/app.cljs.edn
   {:require  [pva-parrot.app]
    :init-fns [pva-parrot.app/init]}
   #+END_SRC

** CSS Styles

   #+BEGIN_SRC clojure :noweb no-export :tangle ../src/clj/pva_parrot/styles.clj
   (ns pva-parrot.styles
     (:require [garden.def :refer [defrule defstyles]]
               [garden.stylesheet :refer [rule]]))

   (defstyles base
     [:* {:box-sizing "border-box"}]
     [:body
      {:padding "10px"
       :font-family "Helvetica Neue"
       :font-size   "16px"
       :line-height 1.5}
      [:#welcome-page
       [:img
        {:max-width "400px"
         :float "left"}]]
      [:.panel
       [:.panel-title
        {:text-align "center"
         :font-size "25px"}]]])

   <<styles grid>>
   #+END_SRC

   A class =.top-buffer=, used to add a top padding to bootstrap grid rows.
   Without this, there is no gap between rows.

   #+BEGIN_SRC clojure :noweb-ref "styles grid"
   (defstyles grid
     [:.top-buffer { :margin-top "20px"}])
   #+END_SRC

* Libraries

  Libraries will be factored out and put into dedicated git repos later.

** Plotting

   Libraries for plotting data.

  #+BEGIN_SRC clojure :tangle ../src/cljs/pva_parrot/plot.cljs
  (ns pva-parrot.plot
    (:require [reagent.core :as reagent]))

  (defn- plot
    ([comp]
     (let [data [{:label "foo"
                  :points {:show true}
                  :color "#E72510"
                  :data (-> comp reagent/props :data)}]
           plot-options {:grid {:hoverable true
                                :clickable true}}]
       (.plot js/$ (reagent/dom-node comp)
         (clj->js data)
         (clj->js plot-options)))))

  (defn plot-component []
    (reagent/create-class
      {:component-did-mount plot
       :component-did-update plot
       :display-name "plot-component"
       :reagent-render (fn [] [:div.plot-container
                              {:style {:width "100%"
                                       :height "500px"}}])}))

  #+END_SRC

** Client side websocket implementation

   The custom URL function =chsk-url-fn= is a hack to make the client establish a
   connection with the host on a different port.
   I did not want to couple the backend service and the GUI by serving them from
   the same web server instance.

   So far I could not find a better way to achieve this with the =sente= API.
   This also will fail when falling back to AJAX without handling CORS properly.
   So far I will stick to this, should be enough for an MVP.

   A more proper way to deal with this would be to use a reverse proxy and have
   it point to the corresponding ports, based on a path.

   #+BEGIN_SRC clojurescript :noweb no-export :tangle ../src/cljs/pva_parrot/websockets.cljs
   (ns pva-parrot.websockets
     (:require-macros
      [cljs.core.async.macros :as asyncm :refer (go go-loop)])
     (:require [cljs.core.async :as async :refer (<! >! put! chan)]
               [taoensso.encore :as enc    :refer (tracef debugf infof warnf errorf)]
               [taoensso.sente :as sente :refer (cb-success?)]))

   (defn chsk-url-fn [path {:as window-location :keys [protocol host pathname]} websocket?]
     (str (if-not websocket? protocol (if (= protocol "https:") "wss:" "ws:"))
       "//localhost:3333"  (or path pathname)))

   (let [{:keys [chsk ch-recv send-fn state]}
         (sente/make-channel-socket! "/chsk"
           {:type :auto :chsk-url-fn chsk-url-fn})]

     (def chsk       chsk)
     (def ch-chsk    ch-recv)
     (def chsk-send! send-fn)
     (def chsk-state state))

   <<app websockets event handling>>
   #+END_SRC

*** Websocket Event handling
    :PROPERTIES:
    :noweb-ref: app websockets event handling
    :END:
    #+BEGIN_SRC clojure
    (defmulti handle-event (fn [[event-id event-message]] event-id))

    (defmulti event-msg-handler :id)

    (defmethod event-msg-handler :default
      [{:as ev-msg :keys [event]}]
      (debugf "Unhandled event: %s" event))

    (defmethod event-msg-handler :chsk/state
      [{:as ev-msg :keys [?data]}]
      (if (= ?data {:first-open? true})
        (debugf "Channel socket successfully established!")
        (debugf "Channel socket state change: %s" ?data)))

    (defmethod event-msg-handler :chsk/recv
      [{:as ev-msg :keys [?data]}]
      (debugf "Push event from server: %s" ?data)
      (handle-event ?data))

    (defmethod event-msg-handler :chsk/handshake
      [{:as ev-msg :keys [?data]}]
      (let [[?uid ?csrf-token ?handshake-data] ?data]
        (debugf "Handshake: %s" ?data)))

    (sente/start-chsk-router! ch-chsk event-msg-handler)
    #+END_SRC
** Backend Service
   :PROPERTIES:
   :CUSTOM_ID: libs-backend
   :END:

   Libraries handling the communication with a backend server, potentially could
   include the service itself. A backend server is especially imporant if the
   app is not build and used as a desktop application with a corresponding app
   shell and thus not having access to file system etc.

   Using [[https://github.com/ptaoussanis/sente][sente]] for asynchronous, realtime communication.

**** Backend service implementation

     #+BEGIN_SRC clojure :noweb no-export :tangle ../src/clj/pva_parrot/backend/service.clj
     (ns pva-parrot.backend.service
       (:require [ring.middleware.params         :as params]
                 [ring.middleware.keyword-params :as keyword-params]
                 [compojure.core                 :refer :all]
                 [taoensso.sente                 :as sente]
                 [taoensso.timbre                :as timbre :refer (tracef debugf infof warnf errorf)]
                 [clojure.data.csv               :as csv]
                 [pva-parrot.calc.pca            :as pca]
                 ))

     <<backend service websocket handlers>>

     (defroutes api-handlers
       (GET "/" [] "You found the PVA Parrot backend service!")
       <<backend service websocket routes>>
       )

     <<backend service middlewares>>

     #+END_SRC

**** Websockets

     Websocket related routes:
     #+BEGIN_SRC clojure :noweb-ref "backend service websocket routes"
     (GET  "/chsk" request (ring-ajax-get-or-ws-handshake request))
     (POST "/chsk" request (ring-ajax-post                request))
     #+END_SRC

     Set up the server side websocket communication handlers:
     #+BEGIN_SRC clojure :noweb-ref "backend service websocket handlers"
     (let [{:keys [ch-recv send-fn ajax-post-fn ajax-get-or-ws-handshake-fn connected-uids]}
           (sente/make-channel-socket! {})]
       (def ring-ajax-post                ajax-post-fn)
       (def ring-ajax-get-or-ws-handshake ajax-get-or-ws-handshake-fn)
       (def ch-chsk                       ch-recv)
       (def chsk-send!                    send-fn)
       (def connected-uids                connected-uids))
     #+END_SRC

**** Middlewares

     Both "params" middlewares are needed by the websocket library =sente=.
     #+BEGIN_SRC clojure :noweb-ref "backend service middlewares"

     (def api (-> api-handlers
                (keyword-params/wrap-keyword-params)
                (params/wrap-params)))

     #+END_SRC

**** Event handling
***** Basic setup
      Incoming events are handled by a multimethod which dispatches on the =:id=
      of the event.

      The default message handler bounces the message back to the sender if a
      reply funcition was defined. The return message indicates that it did not
      match any known events on the server.

      #+BEGIN_SRC clojure :noweb no-export :noweb-ref "backend service websocket handlers"
      (defmulti event-msg-handler :id)

      (defmethod event-msg-handler :default
        [{:as event-msg :keys [event id ?data ring-req ?reply-fn send-fn]}]
        (when ?reply-fn
          (?reply-fn {:unmatched-event-as-echoed-from-server event})))

      (sente/start-chsk-router! ch-chsk event-msg-handler)

      <<backend service websocket handlers data-import>>

      #+END_SRC

***** Data import

      The Eigenvectors are determined via the PCA function as the =:rotation=
      key's value.
      #+BEGIN_SRC clojure :noweb-ref "backend service websocket handlers data-import"

      (defmethod event-msg-handler :data-import/csv-sent
        [{:as event-msg :keys [event id ?data ring-req ?reply-fn send-fn]}]
        (when ?data
          (let [uid            (get-in ring-req [:session :uid])
                csv-data       (csv/read-csv (:file-body ?data))
                csv-headings   (first csv-data)
                csv-body       (rest csv-data)
                pca-data       (pca/components csv-body)
                pca-std-devs   (:std-dev pca-data)
                eigen-values   (:eigen-values pca-data)
                eigen-vectors  (:rotation pca-data)
                reply-msg      [:data-import/file-returned
                                {:parsed-data   {:headings csv-headings :body csv-body}
                                 :std-devs      {:headings nil :body [pca-std-devs]}
                                 :eigen-values  {:headings nil :body [eigen-values]}
                                 :eigen-vectors {:headings nil :body eigen-vectors}
                                 }]]

            (chsk-send! uid reply-msg))))
      #+END_SRC

**** Tests
     #+BEGIN_SRC clojure :tangle ../test/pva_parrot/backend/service_test.clj
     (ns pva-parrot.backend.service-test
       (:require [clojure.test :refer :all]
                 [pva-parrot.backend.service :refer :all]))

     (deftest backend-service
       (testing "Event Handling"

         (testing "setup"
           (is chsk-send! "send function is defined"))

         (testing "file import"
           (let [message-id :data-import/csv-sent]

             (is (= nil (event-msg-handler {:id message-id}))
               "without given data it returns nil")))))
     #+END_SRC

** Calculations
   Libraries for running calculations on data.
   #+BEGIN_SRC clojure :tangle ../src/clj/pva_parrot/calc/pca.clj
   (ns pva-parrot.calc.pca
     (:require [incanter.core :refer :all]
               [incanter.stats :refer :all]))

   (defn vals-to-lists [hash-map]
     (zipmap (keys hash-map) (map to-vect (vals hash-map))))

   (defn calc-eigenvalues [pca-data]
     (map #(* % %) (:std-dev pca-data)))

   (defn components [data]
     "Calulates principal components and eigen values.
      Returns map of results with the actual results converted to list of lists."
     (let [mat (to-matrix (to-dataset data))
           pca-data (principal-components mat)]
       (-> pca-data
         (assoc :eigen-values (calc-eigenvalues pca-data))
         (vals-to-lists))))

   #+END_SRC
** Libraries to be started

*** Project Handling

    Libraries to manage and handle PVA projects and their resources. Includes version control and backup for projects.

*** Desktop App Shells

    Libraries to run the app as a desktop application. Candidates for this are
    node-webkit and atom-shell.

*** I/O

    Libraries for getting data in and out of the app. This includes for example
    file, database and web service access.
