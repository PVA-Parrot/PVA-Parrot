#+TITLE: PVA-Parrot: An application for polytopic vector analysis
#+AUTHOR: Nils Blum-Oeste
#+EMAIL: nils@blum-oeste.de
#+LANGUAGE: en
#+STARTUP: align lognotestate
#+INFOJS_OPT: view:info toc:t
#+HTML_DOCTYPE: html5
#+HTML_CONTAINER_CLASS: container
#+HTML_HEAD: <script src="http://code.jquery.com/jquery-2.1.3.min.js"></script>
#+HTML_HEAD: <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
#+HTML_HEAD: <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/languages/clojure.min.js"></script>
#+HTML_HEAD: <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/languages/bash.min.js"></script>
#+HTML_HEAD: <script src="weave-resources/export.js"></script>
#+HTML_HEAD: <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/monokai.min.css">
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.2/css/bootstrap.min.css" />
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="weave-resources/htmlize.css" />

#+OPTIONS: html-link-use-abs-url:nil html-postamble:nil html-preamble:t html-scripts:t html-style:nil html5-fancy:t
#+OPTIONS: tex:t

#+PROPERTY: mkdirp yes

* Introduction
  PVA-Parrot is an application for doing polytopic vector analysis. This is the
  main application.

* Project Information

  The application version:
  #+BEGIN_SRC clojure :noweb-ref version
  "0.1.0"
  #+END_SRC

  The application description:
  #+BEGIN_SRC clojure :noweb-ref description
  "A GUI application for polytopic vector analysis (PVA)."
  #+END_SRC

* Developing and building

 Instructions about developing and building the application.

** Prerequisites
   A JVM installation is required.

   Boot needs to be installed:
   #+BEGIN_SRC bash
   $ mv boot.sh boot && chmod a+x boot && sudo mv boot /usr/local/bin
   #+END_SRC

** Boot project setup
    #+BEGIN_SRC clojure :noweb no-export :tangle ../build.boot
    (set-env!
      <<boot source paths>>
      <<boot resource paths>>
      :dependencies '[
        <<boot dependencies>>
      ])

    <<boot tasks>>

    (task-options!
      <<boot tasks options>>)
    #+END_SRC

*** Classpath declarations

    Source paths are where source code files reside, both Clojure and
    Clojurescript paths are given and namespaces will be added to the classpath
    by boot.

    #+BEGIN_SRC clojure :noweb-ref "boot source paths"
      :source-paths #{"src/cljs" "src/clj"}
    #+END_SRC

    The resource paths will be on the classpath, too. Files in the resource
    paths will be treated as final articats in the build.

    #+BEGIN_SRC clojure :noweb-ref "boot resource paths"
      :resource-paths #{"resources"}
    #+END_SRC

*** Dependencies declaration
    :PROPERTIES:
    :noweb-ref: boot dependencies
    :END:

   - Clojurescript :: essential for the GUI client logic.
   #+BEGIN_SRC clojure
   [org.clojure/clojurescript "0.0-2814"]
   #+END_SRC

   - boot-cljs :: compilation of cljs files from boot tasks
   #+BEGIN_SRC clojure
   [adzerk/boot-cljs      "0.0-2814-1" :scope "test"]
   #+END_SRC

   - boot-reload :: trigger reload in browser when files changes
   #+BEGIN_SRC clojure
   [adzerk/boot-reload    "0.2.4"      :scope "test"]
   #+END_SRC

   - boot-http :: a simple HTTP serve task
   #+BEGIN_SRC clojure
   [pandeiro/boot-http    "0.6.3-SNAPSHOT"      :scope "test"]
   #+END_SRC

   - boot-notify :: visual notifications of boot build status
   #+BEGIN_SRC clojure
   [jeluard/boot-notify   "0.1.1"      :scope "test"]
   #+END_SRC

   - boot-garden :: compile garden data to CSS
   #+BEGIN_SRC clojure
   [boot-garden           "1.2.5-2"    :scope "test"]
   #+END_SRC

   - reagent :: clojurescript library for Facebook React, used for UI
        programming, linking app state with UI
   #+BEGIN_SRC clojure
   [reagent               "0.5.0-alpha3"]
   #+END_SRC

   - sente :: socket and AJAX communication library, backend and frontend
   #+BEGIN_SRC clojure
   [com.taoensso/sente "1.3.0"]
   #+END_SRC

*** Tasks definitions
    :PROPERTIES:
    :noweb-ref: boot tasks
    :END:

    These are the tasks for the GUI application. Libs may define their own,
    additional tasks, e.g. [[id:libs-backend]]

    #+BEGIN_SRC clojure
    (require
      '[adzerk.boot-cljs      :refer [cljs]]
      '[adzerk.boot-reload    :refer [reload]]
      '[pandeiro.boot-http    :refer [serve]]
      '[boot-garden.core      :refer [garden]]
      '[jeluard.boot-notify   :refer [notify]])


    (deftask build []
      (comp
        (notify)
        (cljs)
        (garden :styles-var 'pva-parrot.styles/base
          :vendors ["webkit"]
          :auto-prefix #{:align-items}
          :output-to "css/garden.css")))

    (deftask dev-run []
      (comp (serve)
        (watch)
        (reload)
        (build)))

    (deftask production []
      (task-options! cljs {:optimizations :advanced
                           :compiler-options {:closure-defines {:goog.DEBUG false}}}
        garden {:pretty-print false})
      identity)

    (deftask development []
      (task-options! cljs {:optimizations :none
                           :unified-mode true
                           :source-map true}
        reload {:on-jsload 'pva-parrot.app/init})
      identity)

    (deftask prod
      "Simple alias to run application in production mode
       No REPL or automatic reloading code inserted."
      []
      (comp (production)
        (serve)
        (watch)
        (build)))

    (deftask dev
      "Simple alias to run application in development mode"
      []
      (comp (development)
        (dev-run)))
    #+END_SRC

*** Tasks options
    :PROPERTIES:
    :noweb-ref: boot tasks options
    :END:
    The macro =task-options!= is used to specify options for tasks. It gets
    passed pairs of tasks and this task's options as a map.

    Options for creating a maven pom.xml project declaration file:
    #+BEGIN_SRC clojure
    pom {:project 'pva-parrot
         :version <<version>>
         :description <<description>>}
    #+END_SRC

*** TODO use CLJSJS
** Troubleshooting
*** JVM Config and Java 8

    boot-clj suggests some options for boot to prevent issues with the JVM: [[https://github.com/boot-clj/boot/wiki/JVM-Options][boot JVM Options]]

    #+BEGIN_SRC bash
    $ echo $BOOT_JVM_OPTIONS
    -Xmx2g -client -XX:+TieredCompilation -XX:TieredStopAtLevel=1 -XX:MaxPermSize=128m -XX:+UseConcMarkSweepGC -XX:+CMSClassUnloadingEnabled -Xverify:none
    #+END_SRC

    I still had memory issues when running boot tasks. Upgrading to Java 8 seems to have fixed theses issues. So I
    recomment using Java 8.

* GUI Application
** Application logic

   Execute =boot dev= to access the application on http://localhost:3000.

   The structure of the main application is like this:
   #+BEGIN_SRC clojure :noweb no-export :tangle ../src/cljs/pva_parrot/app.cljs
   <<app namespace>>
   <<app state>>
   <<app user interface components>>
   <<app pages>>
   <<app initialization and entry point>>
   #+END_SRC

*** Namespace
    The main namespace and entry point of the app.
    #+BEGIN_SRC clojure :noweb-ref "app namespace"

    (ns pva-parrot.app
      (:require [pva-parrot.plot :as plot]
                [pva-parrot.websockets :as websockets]
                [reagent.core :as reagent :refer [atom]]))

    #+END_SRC

*** State
    :PROPERTIES:
    :noweb-ref: app state
    :END:

    Application state is kept in a single Reagent atom. Updating this atom
    triggers propagates changes to the Reagent UI components using data from
    this atom.

    #+BEGIN_SRC clojure

    (defonce app-state (atom {:page :welcome}))

    #+END_SRC

    App state consists of the following data:

    - :page :: the page currently active


    -----
    *Updating app state*

    The current page can be changed with the =swap-page= function:

    #+BEGIN_SRC clojure

    (defn swap-page [target]
      (swap! app-state assoc :page target))

    #+END_SRC

*** UI components
    :PROPERTIES:
    :noweb-ref: app user interface components
    :END:

    The generic =styled-button= function is a Reagent component to render a
    button styled with twitter bootstrap css.

    Based on this base button, further button components are declared to handle
    specific use cases.

    #+BEGIN_SRC clojure

    (defn styled-button [& opts]
      (let [{:keys [style size click-handler contents]} opts
            classes (clojure.string/join " " [(when style (str "btn-" style))
                                              (when size  (str "btn-" size))])]
        [:button.btn {:class classes :on-click click-handler} contents]))

    (defn pages-button [target text & opts]
      [styled-button
        :contents text
        :style "primary"
        :size "lg"
        :click-handler #(swap-page target)])

    (defn back-button [target]
      [styled-button
        :size "sm"
        :contents "back"
        :click-handler #(swap-page target)])

    #+END_SRC

    Components to import files into the application. At the moment this is based
    on uploading a file to the backend via HTML form submissions. When using a
    desktop app shell, this might need to be changed.

    #+BEGIN_SRC clojure
    (defn file-input []
      [:input.btn {:name "import-file" :type "file" :accept "text/*"}])

    (defn submit-file-component [text]
      [:form {:action "/file" :method "POST"}
       [:label "Import a file:"]
       [file-input]
       [styled-button :style "primary" :contents "Import file"]])
    #+END_SRC

*** Pages

    #+BEGIN_SRC clojure :noweb-ref "app pages"


    (defn welcome-page []
      [:div.jumbotron
       [:img.img-responsive {:src "img/parrot.png"}]
       [:h1 "PVA Parrot"]
       [:h2 "An application for polytopic vector analysis"]
       [:hr]
       [pages-button :plot "Show Example Plot"]
       [pages-button :pca "PCA Example"]])

    (defn plot-page []
      [:div
       [plot/plot-component]
       [pages-button :welcome "Show Welcome Screen"]])

    (defn pca-page []
      [:div
       [back-button :welcome "Back to Welcome Screen"]
       [submit-file-component "Import CSV file"]
       ])

    (defn page-component []
      (let [pages {:welcome [welcome-page]
                   :plot [plot-page]
                   :pca [pca-page]}]
        ((:page @app-state) pages)))

    #+END_SRC

*** Init and entry point
    #+BEGIN_SRC clojure :noweb-ref "app initialization and entry point"

    (defn init []
      (reagent.core/render-component [page-component]
        (js/document.getElementById "container")))

    #+END_SRC

** CSS Styles

   #+BEGIN_SRC clojure :tangle ../src/clj/pva_parrot/styles.clj
   (ns pva-parrot.styles
     (:require [garden.def :refer [defrule defstyles]]
               [garden.stylesheet :refer [rule]]))

   (defstyles base
     [:* {:box-sizing "border-box"}]
     [:body
      {:padding "10px"
       :font-family "Helvetica Neue"
       :font-size   "16px"
       :line-height 1.5}])
   #+END_SRC

** HTML entry point
   #+BEGIN_SRC html :tangle ../resources/index.html
   <!doctype html>
   <html>
     <head>
       <meta charset="utf-8">
       <title>PVA Parrot</title>
       <link href="css/bootstrap.min.css" rel="stylesheet" type="text/css" media="screen">
       <link href="css/garden.css" rel="stylesheet" type="text/css" media="screen">
     </head>
     <body>
       <div id="container" class="container">
         <!-- loading screen -->
         <div class="jumbotron">
           <img src="img/parrot.png"  class="img-responsive" />
           <h3>PVA Parrot loading...</h3>
           <p>Initializing application, please wait...</p>
         </div>
       </div>
       <script type="text/javascript" src="js/app.js"></script>
       <script type="text/javascript" src="vendor/jquery.min.js"></script>
       <script type="text/javascript" src="vendor/jquery.flot.min.js"></script>
     </body>
   </html>
   #+END_SRC

** JS entry point
   #+BEGIN_SRC clojure :tangle ../resources/js/app.cljs.edn
   {:require  [pva-parrot.app]
    :init-fns [pva-parrot.app/init]}
   #+END_SRC

* Libraries

  Libraries will be factored out and put into dedicated git repos later.
** Plotting

   Libraries for plotting data.

  #+BEGIN_SRC clojure :tangle ../src/cljs/pva_parrot/plot.cljs
   (ns pva-parrot.plot)

   (defn- plot []
     (let [data [{:label "foo"
                  :points {:show true}
                  :color "#E72510"
                  :data (take 1000 (repeatedly (fn [_] [(rand 200) (rand 600)])))}]
           plot-options {:grid {:hoverable true
                                :clickable true}}]
       (.plot js/$ "#placeholder" (clj->js data) (clj->js plot-options))))

   (def plot-component
     (with-meta
       (fn []
          [:div#placeholder {:style {:width "100%" :height "500px"}}])
       {:component-did-mount plot}))
   #+END_SRC

** I/O

   Libraries for getting data in and out of the app. This includes for example file, database and web service access.
   #+BEGIN_SRC clojure :tangle ../src/cljs/pva_parrot/import.cljs

   #+END_SRC

** Backend Service
   :PROPERTIES:
   :CUSTOM_ID: libs-backend
   :END:


   Libraries handling the communication with a backend server, potentially could
   include the service itself. A backend server is especially imporant if the app
   is not build and used as a desktop application with a corresponding app shell
   and thus not having access to file system etc.

   Using [[https://github.com/ptaoussanis/sente][sente]] for asynchronous, realtime communication.

*** Backend dependencies
    #+BEGIN_SRC clojure :noweb-ref "boot dependencies"
    [ring/ring-core "1.3.2"]
    [http-kit "2.1.19"]
    [compojure "1.3.1"]
    #+END_SRC

*** Backend service implementation

    #+BEGIN_SRC clojure :noweb no-export :tangle ../src/clj/pva_parrot/backend/service.clj
    (ns pva-parrot.backend.service
      (:require [ring.middleware.reload :as reload]
                [ring.middleware.params :as params]
                [ring.middleware.keyword-params :as keyword-params]
                [compojure.core :refer :all]
                [taoensso.sente :as sente]))

    <<backend service websocket handlers>>

    (defroutes api-handlers
      (GET "/" [] "You found the PVA Parrot backend service!")
      <<backend service websocket routes>>
      )

    <<backend service middlewares>>

    #+END_SRC

*** Websockets

    Websocket related routes:
    #+BEGIN_SRC clojure :noweb-ref "backend service websocket routes"
    (GET  "/chsk" request (ring-ajax-get-or-ws-handshake request))
    (POST "/chsk" request (ring-ajax-post                request))
    #+END_SRC

    Set up the server side websocket communication handlers:
    #+BEGIN_SRC clojure :noweb-ref "backend service websocket handlers"
    (let [{:keys [ch-recv send-fn ajax-post-fn ajax-get-or-ws-handshake-fn connected-uids]}
          (sente/make-channel-socket! {})]
      (def ring-ajax-post                ajax-post-fn)
      (def ring-ajax-get-or-ws-handshake ajax-get-or-ws-handshake-fn)
      (def ch-chsk                       ch-recv)
      (def chsk-send!                    send-fn)
      (def connected-uids                connected-uids))
    #+END_SRC

**** Event handling
     Incoming events are handled by a multimethod wich dispatches on the =:id=
     of the event.

     #+BEGIN_SRC clojure :noweb-ref "backend service websocket handlers"
     (defmulti event-msg-handler :id)

     (defmethod event-msg-handler :default
       [{:as event-msg :keys [event id ?data ring-req ?reply-fn send-fn]}]
       (println "Unhandled event: %s", event)
       (when ?reply-fn
         (?reply-fn {:unmatched-event-as-echoed-from-server event})))
     #+END_SRC

*** Middlewares

    Need to wrap the ring reload handler manually and restrict the directory to
    look for updates to the one of the backend. Otherwise I got exceptions
    because it was also trying to compile the =styles.clj= file and could not
    find the =garden= dependency then.
    With the current workaround one also needs to reload the page twice to see
    the latest changes.
    Not sure why this did happen.

    Nicer than this would be using the option =:realod true= for the
    =serve-backend= task, but I could not restrict the directory when doing so.
    ;(

    Both "params" middlewares are needed by the websocket library =sente=.
    #+BEGIN_SRC clojure :noweb-ref "backend service middlewares"

    (def api (-> api-handlers
               (reload/wrap-reload {:dirs ["src/clj/pva_parrot/backend"]})
               (keyword-params/wrap-keyword-params)
               (params/wrap-params)))

    #+END_SRC

*** Boot tasks for backend service
    Start the backend server and the GUI client via =boot serve-backend dev=

    boot task to start the backend server:
    #+BEGIN_SRC clojure :noweb-ref "boot tasks"
        (deftask serve-backend []
          (comp
            (serve :handler 'pva-parrot.backend.service/api
              :httpkit true
              :port 3333)))
    #+END_SRC


*** Client side websocket implementation

  The custom URL function =chsk-url-fn= is a hack to make the client establish a
  connection with the host on a different port.
  I did not want to couple the backend service and the GUI by serving them from
  the same web server instance.

  So far I could not find a better way to achieve this with the =sente= API.
  This also will fail when falling back to AJAX without handling CORS properly.
  So far I will stick to this, should be enough for an MVP.

  A more proper way to deal with this would be to use a reverse proxy and have
  it point to the corresponding ports, based on a path.

  #+BEGIN_SRC clojurescript :tangle ../src/cljs/pva_parrot/websockets.cljs
  (ns pva-parrot.websockets
    (:require-macros
     [cljs.core.async.macros :as asyncm :refer (go go-loop)])
    (:require [cljs.core.async :as async :refer (<! >! put! chan)]
              [taoensso.sente :as sente :refer (cb-success?)]))

  (defn chsk-url-fn [path {:as window-location :keys [protocol host pathname]} websocket?]
      (str (if-not websocket? protocol (if (= protocol "https:") "wss:" "ws:"))
           "//localhost:3333"  (or path pathname)))

  (let [{:keys [chsk ch-recv send-fn state]}
        (sente/make-channel-socket! "/chsk"
          {:type :auto :chsk-url-fn chsk-url-fn})]

    (def chsk chsk)
    (def ch-chsk ch-recv)
    (def chsk-send! send-fn)
    (def chsk-state state))
  #+END_SRC

** Libraries to be started

*** Calculations

    Libraries for running calculations on data.

*** Project Handling

    Libraries to manage and handle PVA projects and their resources. Includes version control and backup for projects.

*** Desktop App Shells

    Libraries to run the app as a desktop application. Candidates for this are
    node-webkit and atom-shell.
