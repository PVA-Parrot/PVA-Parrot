#+INCLUDE: "~/git_repos/PVA-parrot/PVA-Parrot/org/org_settings.org"

* Application logic

  Execute =boot dev= to access the application on http://localhost:3000.

  The structure of the main application is like this:
  #+BEGIN_SRC clojure :noweb no-export :tangle app.cljs
  <<app namespace>>
  <<app state>>
  <<app user interface components>>
  <<app pages>>
  <<app event handling>>
  <<app initialization and entry point>>
  #+END_SRC

*** Namespace
    The main namespace and entry point of the app.
    #+BEGIN_SRC clojure :noweb-ref "app namespace"

    (ns pva-parrot.app
      (:require [taoensso.encore :as enc    :refer (tracef debugf infof warnf errorf)]
                [pva-parrot.plot :as plot]
                [pva-parrot.websockets :as websockets]
                [reagent.core :as reagent :refer [atom]]))

    #+END_SRC

*** State
    :PROPERTIES:
    :noweb-ref: app state
    :END:

    Application state is kept in a single Reagent atom. Updating this atom
    triggers propagates changes to the Reagent UI components using data from
    this atom.

    #+BEGIN_SRC clojure

    (def app-state (atom {:page :welcome
                              :import-file nil
                              :parsed-file nil
                              :plot-data nil
                              :project {:name "My Project"}
                              }))

    #+END_SRC

    App state consists of the following data:

    - :page :: the page currently active
    - :import-file :: file to be imported/uploaded
    - :plot-data :: data to be plotted, currently only a single plot is
         supported and will use this data

    -----
    *Updating app state*

    The current page can be changed with the =swap-page= function:

    #+BEGIN_SRC clojure

    (defn swap-page [target]
      (swap! app-state assoc :page target))

    #+END_SRC

    To import text files, they get stored in in the =app-state= atom. The HTML5
    =FileReader= gets used to retrieve the file contents.

    #+BEGIN_SRC clojure
    (defn store-text-file!
      "Reads a file as text and swaps the result into the app-state for the given key."
      [file key]
      (let [reader (js/FileReader.)]
        (set! (.-onload reader)
          (fn [event]
            (let [file-content (aget event "target" "result")]
              (swap! app-state assoc key file-content))))
        (.readAsText reader file)))

    (defn import-file!
      [event]
      (let [file (aget event "target" "files" 0)]
        (store-text-file! file :import-file)))
    #+END_SRC

*** UI components
    :PROPERTIES:
    :noweb-ref: app user interface components
    :END:

    The generic =styled-button= function is a Reagent component to render a
    button styled with twitter bootstrap css.

    Based on this base button, further button components are declared to handle
    specific use cases.

    #+BEGIN_SRC clojure

    (defn styled-button [& opts]
      (let [{:keys [style size click-handler contents]} opts
            classes (clojure.string/join " " [(when style (str "btn-" style))
                                              (when size  (str "btn-" size))])]
        [:button.btn {:class classes :on-click click-handler} contents]))

    (defn pages-button [target text & opts]
      [styled-button
        :contents text
        :style "primary"
        :size "lg"
        :click-handler #(swap-page target)])

    (defn back-button [target]
      [styled-button
        :size "sm"
        :contents "back"
        :click-handler #(swap-page target)])

    #+END_SRC

    Components to import files into the application. At the moment this is based
    on uploading a file to the backend via HTML form submissions. When using a
    desktop app shell, this might need to be changed.

    #+BEGIN_SRC clojure
    (defn file-input []
      [:input.btn {:name "import-file" :type "file" :accept "text/csv"
                   :on-change import-file!}])

    (defn submit-file [this]
      (let [file-body (:import-file @app-state)
            event-data {:file-body file-body}]
        (.preventDefault this)
        (websockets/chsk-send! [:pva-parrot/import-file event-data])))

    (defn submit-file-component [text]
      [:form.form-inline {:action ""}

       [:div.form-group
        [:label {:for "import-file"} text]
        [file-input]]

       [styled-button :style "primary"
        :contents "Import it"
        :click-handler submit-file]])
    #+END_SRC

    Tables for showing data. Using =DataTables= jQuery plugin.

    #+BEGIN_SRC clojure

       (defn table-header [headings]
         [:tr (map (fn [cell] [:th cell]) headings)])

       (defn table-row [row]
         [:tr (map (fn [cell] [:td cell]) row)])

       (defn table [data]
         (if data
           (let [headings (first data)
                 body (rest data)]
             [:table.table.table-striped.table-bordered {:cell-spacing 0 :width "100%"}
              [:thead
               [table-header headings]]
              [:tbody
               (map table-row body)
               ]])
           [:div]))

       (defn refresh-table [comp]
         (.DataTable (js/$ (reagent/dom-node comp))))

       (defn table-component [data]
         (reagent/create-class {:reagent-render table
                                :component-did-mount refresh-table
                                :component-did-update refresh-table}))

    #+END_SRC

    An accordion to split the app UI into procedural sections. Based on the
    bootstrap accordion.

    #+BEGIN_SRC clojure
    (defn accordion-section [{:keys [key default title]} & contents]
      (let [id (str "collapse-" key)
            heading-id (str "heading-" key)]
        [:div.panel.panel-default
         [:div.panel-heading {:role "tab" :id heading-id}
          [:h1.panel-title
           [:a {:data-toggle "collapse"
                :href (str "#" id) :aria-extended true
                :aria-contols id}
            title]]]
         [:div.panel-collapse.collapse.in {:role "tabpanel" :id id
                                           :aria-labelledby heading-id}
          [:div.panel-body
           contents]
          ]]))

    (defn accordion-component []
      [:div.panel-group {:role "tablist"}
       [accordion-section {:key "analytical-data"
                           :title "1. Analytical Data"}
        [submit-file-component "Import CSV Dataset"]
        [:h2 "Dataset:"]
        [table-component (@app-state :parsed-file)]]
       [accordion-section {:key "sign-components"
                           :title "2. Significant Components"}]
       [accordion-section {:key "comp-and-props"
                           :title "3. Compositions and Proportions"}]])
    #+END_SRC

*** Pages

    #+BEGIN_SRC clojure :noweb-ref "app pages"

    (defn pva-workbook [project]
      [:div
       [:div.col-lg-12
        [back-button :welcome]]
       [:div.row
        [:div.col-lg-12
         [:h1 (str "Project: " (:name @project))]
         [accordion-component]
         ]]])

    (defn welcome-page []
      [:div.jumbotron
       [:img.img-responsive {:src "img/parrot.png"}]
       [:h1 "PVA Parrot"]
       [:h2 "An application for polytopic vector analysis"]
       [:hr]
       [pages-button :pva-workbook "Go to Workbook"]])

    (defn page-component []
      (let [pages {:welcome [welcome-page]
                   :pva-workbook [pva-workbook
                                  (reagent/cursor app-state [:project])]}]
        ((:page @app-state) pages)))

    #+END_SRC

*** Event handling
    :PROPERTIES:
    :noweb-ref: app event handling
    :END:

    #+BEGIN_SRC clojure

    (defmethod websockets/handle-event :pvaparrot/imported-file
      [[_ data]]
      (debugf "Imported data received: %s" data)
      (swap! app-state assoc :parsed-file data))

    #+END_SRC

*** Init and entry point
    #+BEGIN_SRC clojure :noweb-ref "app initialization and entry point"

    (defn init []
      (reagent.core/render-component [page-component]
        (js/document.getElementById "container")))

    #+END_SRC
